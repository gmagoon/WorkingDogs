using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Threading;
using System.Diagnostics;
using WorkingDogsCore;

namespace FilterReads
{
    class Program
    {
        // Filters a set of read against any number of filters. The filters can be inclusive (such as 16S)
        // or exclusive (such as human 18S). Filters are sets of tiles generated by GenerateMerFilter.
        //
        // usage: FilterReads -r tag -t threads [-pairs] [-matches] [-full] [-len minLen] [-s] [-qt minQual] [-o outputDir] [-fasta] [-discards] [+/-lcf] [+f|fz includeFilter minMatches[%]] [-f|fz excludeFilter minMatches[%|pct]] readsFNs
        //
        // -r 16S -t 8 +f current_prokMSA_unaligned_May2011_25.mer 10% -f Human_mitochondria_25.mer 20% -f human_18S_25.mer 20% GH_02d_ATCACG_R?.fastq
        // -r aflatoxin  Contigs\F36-HGM-57\contigs_F36-HGM-57-11.fa -t 16 +f aflatoxinGenes_25.mer 1000

        static long progressReadsRead = 0;
        static long progressReadsAccepted = 0;
        static long progressReadsRejected = 0;
        static bool stopReporter = false;
        static int reportInterval = 60000;
        static StreamWriter matches = null;
        static bool saveMatches = false;
        static bool recursiveSearch = false;
        static string outputDir = null;
        static bool pairedReads = false;
        static bool lowComplexityFilter = false;
        static bool qualTrim = false;
        static int minQual = 0;
        static bool fullLength = false;
        static bool tracing = false;
        static bool saveDiscards = false;

        static object writingLock = new object();               // global lock to serialise writing filtered reads
        //static StreamWriter rejects = null;

        enum FilterType { IncFilter, ExcFilter };

        const int maxReadSize = 1000;
        const int batchSize = 1000;
        const int defaultReadLength = 300;
        const int defaultHeaderLength = 100;
        const int lcSize = 3;                                   // size of small kMer used in low-complexity filter

        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                WriteUsage();
                return;
            }

            string runName = "filtered";
            List<string> readsPatterns = new List<string>();
            int threads = 1;
            int minLen = 0;
            int outputFormat = SeqFiles.formatNone;
            int qualOffset = 0;
            int lcfCount = 0;
            bool lcfPct = false;

            List<string> incFilterNames = new List<string>(5);
            List<int> incFilterMins = new List<int>(5);
            List<bool> incFilterPct = new List<bool>(5);
            List<bool> incFilterFuzzy = new List<bool>(5);
            List<string> excFilterNames = new List<string>(5);
            List<int> excFilterMins = new List<int>(5);
            List<bool> excFilterPct = new List<bool>(5);
            List<bool> excFilterFuzzy = new List<bool>(5);

            for (int p = 0; p < args.Length; p++)
            {
                if (args[p][0] == '-' || args[p][0] == '+')
                {
                    args[p] = args[p].ToLower();

                    if (args[p] == "-h" || args[p] == "-help")
                    {
                        WriteUsage();
                        return;
                    }

                    if (args[p] == "-lcf")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -lcf"))
                            return;
                        try
                        {
                            string matchPCT = args[p + 1];
                            if (matchPCT.EndsWith("%") || matchPCT.EndsWith("pct"))
                            {
                                matchPCT = matchPCT.Replace('%', ' ');
                                matchPCT = matchPCT.Replace("pct", "");
                                matchPCT = matchPCT.Trim();
                                lcfPct = true;
                            }
                            lcfCount = Convert.ToInt32(matchPCT);
                            if (lcfPct && (lcfCount < 0 || lcfCount > 100))
                            {
                                Console.WriteLine("low complexity filter percentage must be between 0 and 100: " + lcfCount);
                                return;
                            }
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after -lcf: " + args[p + 1]);
                            return;
                        }

                        lowComplexityFilter = true;
                        p++;
                        continue;
                    }

                    if (args[p] == "-fasta")
                    {
                        outputFormat = SeqFiles.formatFNA;
                        continue;
                    }

                    if (args[p] == "-full" || args[p] == "fulllength")
                    {
                        fullLength = true;
                        continue;
                    }

                    if (args[p] == "-pairs")
                    {
                        pairedReads = true;
                        continue;
                    }

                    if (args[p] == "-m" || args[p] == "-matches")
                    {
                        saveMatches = true;
                        continue;
                    }

                    if (args[p] == "-s")
                    {
                        recursiveSearch = true;
                        continue;
                    }

                    if (args[p] == "-d" || args[p] == "-discards")
                    {
                        saveDiscards = true;
                        continue;
                    }

                    if (args[p] == "-qualtrim" || args[p] == "-qt" || args[p] == "-tq" || args[p] == "-trimqual")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -qt|-qualTrim"))
                            return;
                        try
                        {
                            minQual = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after -qt|-qualTrim: " + args[p + 1]);
                            return;
                        }
                        qualTrim = true;
                        p++;
                        continue;
                    }

                    if (args[p] == "-r" || args[p] == "-run")
                    {
                        if (!CheckForParamValue(p, args.Length, "run name string expected after -r|-run"))
                            return;
                        runName = args[p + 1];
                        p++;
                        continue;
                    }

                    if (args[p] == "-o")
                    {
                        if (!CheckForParamValue(p, args.Length, "output directory expected after -o"))
                            return;
                        outputDir = args[p + 1];
                        p++;
                        continue;
                    }

                    if (args[p] == "-t" || args[p] == "-threads")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -t|-threads"))
                            return;
                        try
                        {
                            threads = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after the -t|-threads parameter: " + args[p + 1]);
                            return;
                        }
                        p++;
                        continue;
                    }

                    if (args[p] == "-l" || args[p] == "-len")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -l|-length"))
                            return;
                        try
                        {
                            minLen = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after the -l|-len parameter: " + args[p + 1]);
                            return;
                        }
                        p++;
                        continue;
                    }


                    if (args[p] == "-f" || args[p] == "-filter" || args[p] == "-fz" || args[p] == "-fuzzyfilter")
                    {
                        if (!CheckForParamValue(p, args.Length, "filter file name string expected after -f|-filter|-fz|-fuzzyfilter"))
                            return;
                        excFilterNames.Add(args[p + 1]);
                        try
                        {
                            string matchPCT = args[p + 2];
                            bool pctFound = false;
                            if (matchPCT.EndsWith("%") || matchPCT.EndsWith("pct"))
                            {
                                matchPCT = matchPCT.Replace('%', ' ');
                                matchPCT = matchPCT.Replace("pct", "");
                                matchPCT = matchPCT.Trim();
                                pctFound = true;
                            }
                            int minCount = Convert.ToInt32(matchPCT);
                            excFilterMins.Add(minCount);
                            excFilterPct.Add(pctFound);
                            if (pctFound && (minCount < 0 || minCount > 100))
                                {
                                Console.WriteLine("-f filter percentage must be between 0 and 100: " + minCount);
                                return;
                            }
                            if (args[p] == "-f" || args[p] == "-filter")
                                excFilterFuzzy.Add(false);
                            else
                                excFilterFuzzy.Add(true);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number or percentage after the filter name: " + args[p + 2]);
                            return;
                        }
                        p += 2;
                        continue;
                    }

                    if (args[p] == "+f" || args[p] == "+filter" || args[p] == "+fz" || args[p] == "+fuzzyfilter")
                    {
                        if (!CheckForParamValue(p, args.Length, "filter file name string expected after +f|+filter|+fz|+fuzzyfilter"))
                            return;
                        incFilterNames.Add(args[p + 1]);
                        try
                        {
                            string matchPCT = args[p + 2];
                            bool pctFound = false;
                            if (matchPCT.EndsWith("%") || matchPCT.EndsWith("pct"))
                            {
                                matchPCT = matchPCT.Replace('%', ' ');
                                matchPCT = matchPCT.Replace("pct", "");
                                matchPCT = matchPCT.Trim();
                                pctFound = true;
                            }
                            int minCount = Convert.ToInt32(matchPCT);
                            incFilterMins.Add(minCount);
                            incFilterPct.Add(pctFound);
                            if (pctFound && (minCount < 0 || minCount > 100))
                            {
                                Console.WriteLine("+f filter percentage must be between 0 and 100: " + minCount);
                                return;
                            }
                            if (args[p] == "+f" || args[p] == "+filter")
                                incFilterFuzzy.Add(false);
                            else
                                incFilterFuzzy.Add(true);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number or percentage after the filter name: " + args[p + 2]);
                            return;
                        }
                        p += 2;
                        continue;
                    }

                } // arg starts with +/-

                readsPatterns.Add(args[p]);
            }

            int merSize = 0;                        // set from filters

            // add lcf as the last 'exclusion' filter
            if (lowComplexityFilter)
            {
                excFilterMins.Add(lcfCount);
                excFilterPct.Add(lcfPct);
            }

            // the final list of files to be filtered, derived by expanding all the names/patterns passed as parameters
            List<string> readsFNs = new List<string>();

            foreach (string readsPattern in readsPatterns)
            {
                string readsPatternPath = null;
                string readsPatternFNP = null;
                GetPathFN(readsPattern, out readsPatternPath, out readsPatternFNP);

                SearchOption so = SearchOption.TopDirectoryOnly;
                if (recursiveSearch)
                    so = SearchOption.AllDirectories;
                string[] readsFNsForPattern = Directory.GetFiles(readsPatternPath, readsPatternFNP, so);

                int noOfReadsFilesReturned = readsFNsForPattern.Length;
                if (noOfReadsFilesReturned == 0)
                {
                    Console.WriteLine("No matching sequences files found for " + readsPattern);
                    return;
                }

                foreach (string readsFN in readsFNsForPattern)
                    readsFNs.Add(readsFN);
            }

            if (outputDir != null)
                Directory.CreateDirectory(outputDir);

            if (pairedReads && readsFNs.Count % 2 != 0)
            {
                Console.WriteLine("-pairs option used but found " + readsFNs.Count + " files");
                return;
            }

            if (incFilterNames.Count == 0 && excFilterNames.Count == 0)
            {
                Console.WriteLine("No filters specified");
                return;
            }

            DateTime start = DateTime.Now;

            List<MerHashSet> incFilters = new List<MerHashSet>(incFilterNames.Count);
            for (int f = 0; f < incFilterNames.Count; f++)
            {
                string fn = incFilterNames[f];
                int filterMerSize;
                MerHashSet incFilter;
                Console.WriteLine("loading filter " + fn);
                bool loadedOK = LoadTileFile(fn, incFilterFuzzy[f], out incFilter, out filterMerSize);
                if (loadedOK)
                {
                    Console.WriteLine("loaded " + incFilter.Count + " k-mers from " + fn + ". Matching at " + incFilterMins[f] + (incFilterPct[f] ? "%" : ""));
                }
                else
                {
                    Console.WriteLine("failed to load " + fn);
                    return;
                }
                incFilters.Add(incFilter);
                if (merSize > 0 && filterMerSize != merSize)
                {
                    Console.WriteLine("mer size mismatch for " + fn + " (expected " + merSize + ")");
                    return;
                }
                merSize = filterMerSize;
            }

            List<MerHashSet> excFilters = new List<MerHashSet>(excFilterNames.Count);
            for (int f = 0; f < excFilterNames.Count; f++)
            {
                string fn = excFilterNames[f];
                Console.WriteLine("loading filter " + fn);
                int filterMerSize;
                MerHashSet excFilter; 
                bool loadedOK = LoadTileFile(fn, excFilterFuzzy[f], out excFilter, out filterMerSize);
                if (loadedOK)
                {
                    Console.WriteLine("loaded " + excFilter.Count + " k-mers from " + fn + " matching at " + excFilterMins[f] + (excFilterPct[f] ? "%" : ""));
                }
                else
                {
                    Console.WriteLine("failed to load " + fn);
                    return;
                }
                excFilters.Add(excFilter);
                if (merSize > 0 && filterMerSize != merSize)
                {
                    Console.WriteLine("mer size mismatch for " + fn + " (expected " + merSize + ")");
                    return;
                }
                merSize = filterMerSize;
            }

            if (lowComplexityFilter)
            {
                excFilters.Add(null);
                int lcfIdx = excFilters.Count - 1;
                Console.WriteLine("enabled low-complexity filtering at " + excFilterMins[lcfIdx] + (excFilterPct[lcfIdx] ? "%" : ""));
            }

            Console.WriteLine("loaded " + (incFilters.Count + excFilters.Count) + " filters in " + (DateTime.Now - start).TotalSeconds.ToString("#.0") + "s");

            if (minLen == 0)
                minLen = merSize;

            int noOfReadsFilesPerLoop = pairedReads ? 2 : 1;
            int noOfReadsFiles = readsFNs.Count;
            StreamReader[] reads = new StreamReader[noOfReadsFilesPerLoop];
            BufferedReader[] bufferedReads = new BufferedReader[noOfReadsFilesPerLoop];
            string[] readsDisplayFNs = new string[noOfReadsFilesPerLoop];
            StreamWriter[] filteredReads = new StreamWriter[noOfReadsFilesPerLoop];
            string[] filteredReadsFNs = new string[noOfReadsFilesPerLoop];
            StreamWriter[] discardedReads = null;
            string[] discardedReadsFNs = null;
            if (saveDiscards)
            {
                discardedReads = new StreamWriter[noOfReadsFilesPerLoop];
                discardedReadsFNs = new string[noOfReadsFilesPerLoop];
            }
            if (saveMatches)
                matches = new StreamWriter(runName + "_matches.txt");
            //rejects = new StreamWriter("lcfRejects.fna");

            int fileFormat = SeqFiles.formatNone;
            StreamReader testFileFormat = new StreamReader(readsFNs[0]);
            string firstLine = testFileFormat.ReadLine();
            testFileFormat.Close();
            if (firstLine != null)
            {
                if (firstLine[0] == '>')
                    fileFormat = SeqFiles.formatFNA;
                else
                if (firstLine[0] == '@')
                    fileFormat = SeqFiles.formatFASTQ;
            }
            if (fileFormat == SeqFiles.formatNone)
            {
                Console.WriteLine(readsFNs[0] + " does not appear to be either fasta or fastq");
                return;
            }
            if (outputFormat == SeqFiles.formatNone)
                outputFormat = fileFormat;

            if (qualTrim && fileFormat != SeqFiles.formatFASTQ)
            {
                Console.WriteLine("can only quality-trim fastq files, option ignored");
                qualTrim = false;
            }

            if (qualTrim)
            {
                bool fullQualHeader;
                qualOffset = SeqFiles.ResolveFastqQualAmbiguity(readsFNs[0], out fullQualHeader);
            }

            int fileStep = pairedReads ? 2 : 1;

            long totalAcceptedReads = 0;
            long totalRejectedReads = 0;
            long totalSkippedReadsShort = 0;
            long totalPairedAcceptedReads = 0;
            long totalNoOfReads = 0;
            long keptReadsCount = 0;
            long discardedReadsCount = 0;
            long totalBasesQualTrimmed = 0;
            start = DateTime.Now;

            string discardsName = "discards";
            if (runName == discardsName)
                discardsName = "dropped";

            // start the monitor/synchronising thread
            Thread monitorProgress = new Thread(RateReporter);
            monitorProgress.Priority = ThreadPriority.AboveNormal;
            monitorProgress.Start();

            for (int f = 0; f < noOfReadsFiles; f += fileStep)
            {
                InitialiseFile(0, runName, discardsName, outputFormat, readsFNs[f], reads, bufferedReads, readsDisplayFNs, filteredReads, filteredReadsFNs, discardedReads, discardedReadsFNs, fileFormat);
                if (pairedReads)
                    InitialiseFile(1, runName, discardsName, outputFormat, readsFNs[f+1], reads, bufferedReads, readsDisplayFNs, filteredReads, filteredReadsFNs, discardedReads, discardedReadsFNs, fileFormat);
                keptReadsCount = 0;               

                // prepare the reader threads and their parameters
                Thread[] filterThreads = new Thread[threads];
                readerThreadParams[] readerParams = new readerThreadParams[threads];

                for (int t = 0; t < threads; t++)
                {
                    readerParams[t] = new readerThreadParams();
                    readerParams[t].incFilters = incFilters;
                    readerParams[t].incFilterMins = incFilterMins;
                    readerParams[t].incFilterPct = incFilterPct;
                    readerParams[t].excFilters = excFilters;
                    readerParams[t].excFilterMins = excFilterMins;
                    readerParams[t].excFilterPct = excFilterPct;
                    readerParams[t].merSize = merSize;
                    readerParams[t].minLen = minLen;
                    readerParams[t].fileFormat = fileFormat;
                    readerParams[t].outputFormat = outputFormat;
                    readerParams[t].qualOffset = qualOffset;
                    readerParams[t].minQual = minQual;
                    readerParams[t].acceptedReads = 0;
                    readerParams[t].rejectedReads = 0;
                    readerParams[t].noOfReads = 0;
                    readerParams[t].pairedAcceptedReads = 0;
                    readerParams[t].bufferedReads = bufferedReads;
                    readerParams[t].filteredReads = filteredReads;
                    readerParams[t].discardedReads = discardedReads;
                    readerParams[t].readsDisplayFNs = readsDisplayFNs;
                    filterThreads[t] = new Thread(new ParameterizedThreadStart(Program.FilterReads));
                }

                if (pairedReads)
                    Console.WriteLine("filtering " + readsDisplayFNs[0] + " and " + readsDisplayFNs[1]);
                else
                    Console.WriteLine("filtering " + readsDisplayFNs[0]);

                // start the filtering reads for this file (pair)
                for (int t = 0; t < threads; t++)
                {
                    filterThreads[t].Start(readerParams[t]);
                }

                // and wait for all threads to finish
                for (int t = 0; t < filterThreads.Length; t++)
                {
                    filterThreads[t].Join();
                    totalAcceptedReads += readerParams[t].acceptedReads;
                    totalRejectedReads += readerParams[t].rejectedReads;
                    totalSkippedReadsShort += readerParams[t].skippedReadsShort;
                    totalNoOfReads += readerParams[t].noOfReads;
                    totalPairedAcceptedReads += readerParams[t].pairedAcceptedReads;
                    keptReadsCount += readerParams[t].acceptedReads;
                    discardedReadsCount += readerParams[t].rejectedReads;
                    totalBasesQualTrimmed += readerParams[t].basesQualTrimmed;
                    //Console.WriteLine("finished matching thread " + t);
                }

                foreach (StreamWriter fr in filteredReads)
                    fr.Close();

                if (discardedReads != null)
                    foreach (StreamWriter dr in discardedReads)
                        dr.Close();

                foreach (BufferedReader br in bufferedReads)
                    br.Close();

                // don't save empty files
                for (int i = 0; i < filteredReads.Length; i++)
                {
                    if (keptReadsCount == 0)
                        File.Delete(filteredReadsFNs[i]);
                    if (saveDiscards && discardedReadsCount == 0)
                        File.Delete(discardedReadsFNs[i]);
                }

            } // for all files (in pairs if necessary)

            monitorProgress.Abort();
            monitorProgress.Join();

            if (matches != null)
                matches.Close();
            //rejects.Close();

            Console.WriteLine("Retained " + totalAcceptedReads + " from " + totalNoOfReads + " sequences (" +
                                totalPairedAcceptedReads + " pairs) in " +
                                (DateTime.Now - start).TotalSeconds.ToString("#.0") + "s; " +
                                totalRejectedReads + " rejected;" + 
                                " skipped: " + totalSkippedReadsShort + " (too short); " + totalBasesQualTrimmed + " bases qual-trimmed");

            //Console.ReadLine();

        }

        private static void InitialiseFile(int idx, string runName, string discardsName, int outputFormat, string readsFN, StreamReader[] reads, BufferedReader[] bufferedReads, string[] readsDisplayFNs, 
                                           StreamWriter[] filteredReads, string[] filteredReadsFNs, StreamWriter[]discardedReads, string[] discardedReadsFNs, int fileFormat)
        {
            reads[idx] = new StreamReader(readsFN);
            bufferedReads[idx] = new BufferedReader(fileFormat, reads[idx], null);

            string fileSuffix = readsFN.Substring(readsFN.LastIndexOf('.'));
            string filePrefix = readsFN.Substring(0, readsFN.LastIndexOf('.'));
            string fileWithoutSuffix = readsFN.Substring(readsFN.LastIndexOf('\\') + 1);
            fileWithoutSuffix = fileWithoutSuffix.Substring(0, fileWithoutSuffix.LastIndexOf('.'));
            string finalFileSuffix = fileSuffix;
            // if we're converting the file format, it must be from fastq to fasta
            if (fileFormat != outputFormat)
                finalFileSuffix = ".fa";

            if (outputDir != null)
            {
                char fsSlash = Path.DirectorySeparatorChar;
                filePrefix = filePrefix.Substring(filePrefix.LastIndexOf(fsSlash) + 1);
                filePrefix = Path.Combine(outputDir, filePrefix);
            }
            string filteredFN = filePrefix + "_" + runName + finalFileSuffix;
            filteredReads[idx] = new StreamWriter(filteredFN);
            readsDisplayFNs[idx] = fileWithoutSuffix + fileSuffix;
            filteredReadsFNs[idx] = filteredFN;

            if (discardedReads != null)
            {
                string discardsFN = filePrefix + "_" + discardsName + finalFileSuffix;
                discardedReads[idx] = new StreamWriter(discardsFN);
                discardedReadsFNs[idx] = discardsFN;
            }
        }

        private static void WriteUsage()
        {
            Console.WriteLine("usage: FilterReads -r tag -t threads [-pairs] [-full] [-matches] [-len minLen] [-s] [-qt minQual] [-o outputDir] [-fasta] [-discards] [+/-lcf] [+f|fz includeFilter minMatches[%|pct]] [-f|fz excludeFilter minMatches[%|pct]] readsFNs");
        }

        private static bool CheckForParamValue(int p, int argsLength, string msg)
        {
            if (p == argsLength)
            {
                Console.WriteLine(msg);
                return false;
            }
            return true;
        }

        private static void GetPathFN(string readsFN, out string readsPath, out string readsFNP)
        {
            char FSC = Path.DirectorySeparatorChar;
            string FSS = new string(FSC, 1);
            readsPath = null;
            if (readsFN.Contains(FSS))
            {
                readsPath = readsFN.Substring(0, readsFN.LastIndexOf(FSC));
                readsFNP = readsFN.Substring(readsFN.LastIndexOf(FSC) + 1);
            }
            else
            {
                readsPath = Directory.GetCurrentDirectory();
                readsFNP = readsFN;
            }
        }
        
        private static bool LoadTileFile(string tilesFN, bool load1Subvariants, out MerHashSet filter, out int merSize)
        {
            BinaryReader tiledMersFile = null;
            string tiledMersFN = null;
            bool EOF = false;

            merSize = 0;
            filter = null;

            bool tileFileOpened = false;
            try
            {
                tiledMersFN = tilesFN;
                tiledMersFile = new BinaryReader(File.Open(tiledMersFN, FileMode.Open, FileAccess.Read, FileShare.Read));
                tileFileOpened = true;
            }
            catch
            {
                tileFileOpened = false;
            }

            if (!tileFileOpened)
                try
                {
                    string myDocs = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                    tiledMersFN = myDocs + "\\code\\" + tilesFN;
                    tiledMersFile = new BinaryReader(File.Open(tiledMersFN, FileMode.Open, FileAccess.Read, FileShare.Read));

                    tileFileOpened = true;
                }
                catch
                {
                    tileFileOpened = false;
                }

            if (!tileFileOpened)
            {
                Console.WriteLine("kMer file (" + tilesFN + ") not found");

                return false;
            }

            FileInfo fi = new FileInfo(tiledMersFN);
            long tileFileLength = fi.Length;
            int mersInFile = (int)((tileFileLength - 4) / 8 + 1);

            merSize = tiledMersFile.ReadInt32();
            if (load1Subvariants)
                mersInFile = mersInFile * 4;

            List<ulong> merVariants = new List<ulong>(merSize * 4);

            filter = new MerHashSet(mersInFile, merSize); 

            while (!EOF)
            {
                try                                             // read the next mer from the binary stream - will generate exception at EOF
                {
                    ulong mer = tiledMersFile.ReadUInt64();     // only distinct canonical mers are expected in this file

                    filter.AddNoCheck(mer);                  // no need to check as mers will be distinct 
                }
                catch
                {
                    EOF = true;
                    break;
                }
            }

            tiledMersFile.Close();

            if (load1Subvariants)
            {
                //ulong[] nvMers = new ulong[filter.Count];
                //filter.CopyEntries(nvMers);

                //for (int m = 0; m < nvMers.Length; m++)
                //{
                //    ulong mer = nvMers[m];
                //    // add this mer and its variants to the filter
                //    merVariants.Clear();
                //    merVariants.Add(mer);
                //    int vNo = kMers.GenerateMerSubVariants(mer, merVariants, merSize) + 1;
                //    for (int v = 0; v < vNo; v++)
                //    {
                //        ulong merVariant = merVariants[v];
                //        filter.AddIfNotPresent(merVariant);
                //    }
                //}
                filter.AddSubVariants();
            }
            
            filter.Optimise();

            return true;
        }

        private static void FilterReads(object threadParams)
        {
            readerThreadParams theseParams = (readerThreadParams)threadParams;

            List<MerHashSet> incFilters = theseParams.incFilters;
            List<int> incFilterMins = theseParams.incFilterMins;
            List<bool> incFilterPct = theseParams.incFilterPct;
            List<MerHashSet> excFilters = theseParams.excFilters;
            List<int> excFilterMins = theseParams.excFilterMins;
            List<bool> excFilterPct = theseParams.excFilterPct;
            int merSize = theseParams.merSize;
            int minLen = theseParams.minLen;
            BufferedReader[] bufferedReads = theseParams.bufferedReads;
            int fileFormat = theseParams.fileFormat;
            int outputFormat = theseParams.outputFormat;
            string[] readsDisplayFNs = theseParams.readsDisplayFNs;
            StreamWriter[] filteredReads = theseParams.filteredReads;
            StreamWriter[] discardedReads = theseParams.discardedReads;
            int minQual = theseParams.minQual;
            int qualOffset = theseParams.qualOffset;

            Dictionary<ulong, int> distinctTriplets = new Dictionary<ulong, int>(1000);

            int noOfReadsFiles = bufferedReads.Length;

            long matchingReads = 0;
            long rejectedReads = 0;
            long skippedReadsShort = 0;
            long pairedAcceptedReads = 0;
            long noOfReads = 0;
            long basesQualTrimmed = 0;

            Sequence[][] headerSet = new Sequence[noOfReadsFiles][];             // a set of read headers
            Sequence[][] readSet = new Sequence[noOfReadsFiles][];               // a set of reads, possibly one from each file (length+char[])
            Sequence[][] qualHeaderSet = new Sequence[noOfReadsFiles][];         // set of headers for the quals
            Sequence[][] qualsSet = new Sequence[noOfReadsFiles][];              // set of quals 
            bool[][] acceptedRead = new bool[noOfReadsFiles][];                  // results of filtering a batch of reads (status per read)
            bool[][] rejectedRead = new bool[noOfReadsFiles][];
            List<int>[][] savedMatchedAcceptLocs = new List<int>[noOfReadsFiles][];    // saved matching kMer locations (acccept)
            List<int>[][] savedMatchedRejectLocs = new List<int>[noOfReadsFiles][];    // saved matching kMer locations (reject)
            List<int>[][] savedMatchedRejectSizes = new List<int>[noOfReadsFiles][];   // kMer lengths for saved reject kMers

            int filesStillActive = noOfReadsFiles;                               // how many active reads files are still around

            for (int p = 0; p < noOfReadsFiles; p++)
            {
                headerSet[p] = new Sequence[batchSize];
                readSet[p] = new Sequence[batchSize];
                qualHeaderSet[p] = new Sequence[batchSize];
                qualsSet[p] = new Sequence[batchSize];
                acceptedRead[p] = new bool[batchSize];
                rejectedRead[p] = new bool[batchSize];
                for (int r = 0; r < batchSize; r++)
                {
                    headerSet[p][r] = new Sequence(defaultHeaderLength);
                    readSet[p][r] = new Sequence(defaultReadLength);
                    qualHeaderSet[p][r] = new Sequence(defaultHeaderLength);
                    qualsSet[p][r] = new Sequence(defaultReadLength);
                }
                if (saveMatches)
                {
                    savedMatchedAcceptLocs[p] = new List<int>[batchSize];
                    savedMatchedRejectLocs[p] = new List<int>[batchSize];
                    savedMatchedRejectSizes[p] = new List<int>[batchSize];
                    for (int r = 0; r < batchSize; r++)
                    {
                        savedMatchedAcceptLocs[p][r] = new List<int>();
                        savedMatchedRejectLocs[p][r] = new List<int>();
                        savedMatchedRejectSizes[p][r] = new List<int>();
                    }
                }
            }

            // per-read and per-set data allocated outside of reading loop for performance reasons
            ulong[] merSet = new ulong[1000];
            bool[] merValid = new bool[1000];
            int[] incMatchesForRead = new int[incFilters.Count];
            int[] excMatchesForRead = new int[excFilters.Count];
            List<int>[] matchedAcceptedMerLocs = new List<int>[incFilters.Count];
            List<int>[] matchedRejectedMerLocs = new List<int>[excFilters.Count];
            for (int i = 0; i < incFilters.Count; i++)
                matchedAcceptedMerLocs[i] = new List<int>();
            for (int i = 0; i < excFilters.Count; i++)
                matchedRejectedMerLocs[i] = new List<int>();
            int[] incFilterMinsRead = new int[incFilterMins.Count];
            int[] excFilterMinsRead = new int[excFilterMins.Count];
            int lastReadLength = 0;

            // low complexity kMer cache
            HashSet<ulong> LCCache = new HashSet<ulong>();
            Dictionary<ulong, int> LCDistinct = new Dictionary<ulong, int>();

            string targetHeader = ">D8QSB6V1:140:HA62CADXX:1:1103:12914:23603";

            while (filesStillActive > 0)
            {
                // read the next read from each of the files together - giving a pair of reads if we have paired reads - and do this for a batch to reduce locking overhead
                int readsRead = 0;                          // no of reads in this batch
                lock (bufferedReads)
                {
                    for (int p = 0; p < noOfReadsFiles; p++)
                    {
                        readsRead = bufferedReads[p].ReadReads(batchSize, headerSet[p], readSet[p], qualHeaderSet[p], qualsSet[p]);

                        if (readsRead != batchSize)
                            filesStillActive--;

                        progressReadsRead += readsRead;
                    }
                } // lock to ensure synchronised reading from all reads files (and pairing)

                // filter the just-acquired batch of reads
                for (int r = 0; r < readsRead; r++)
                {
                    // process each read/pair of reads 
                    for (int p = 0; p < readSet.Length; p++)
                    {
                        noOfReads++;
                        Sequence currentRead = readSet[p][r];

                        if (qualTrim)
                            basesQualTrimmed += SeqFiles.TrimTrailingPoorQuals(readSet[p][r], qualsSet[p][r], minQual, qualOffset);

                        if (currentRead.Length < minLen)
                        {
                            skippedReadsShort++;
                            acceptedRead[p][r] = false;
                            rejectedRead[p][r] = true;
                            progressReadsRejected++;
                            continue;
                        }

                        foreach (List<int> matchedLocs in matchedAcceptedMerLocs)
                            matchedLocs.Clear();
                        foreach (List<int> matchedLocs in matchedRejectedMerLocs)
                            matchedLocs.Clear();

                        // defaults
                        acceptedRead[p][r] = incFilters.Count == 0;
                        rejectedRead[p][r] = false;

                        int currentReadLength = currentRead.Length;
                        int minInHalf = currentReadLength * 5 / 100;
                        if (minInHalf == 0)
                            minInHalf = 1;

                        // calculate min cutoffs for each filter if the read/contig length has changed
                        if (currentReadLength != lastReadLength)
                        {
                            for (int f = 0; f < incFilters.Count; f++)
                            {
                                if (incFilterPct[f])
                                    incFilterMinsRead[f] = currentReadLength * incFilterMins[f] / 100;
                                else
                                    incFilterMinsRead[f] = incFilterMins[f];
                            }
                            for (int f = 0; f < excFilters.Count; f++)
                            {
                                if (excFilterPct[f])
                                    excFilterMinsRead[f] = currentReadLength * excFilterMins[f] / 100;
                                else
                                    excFilterMinsRead[f] = excFilterMins[f];
                            }
                            lastReadLength = currentReadLength;
                        }

                        //if (headerSet[p][r].ToString().StartsWith(targetHeader))
                        //{
                        //    tracing = true;
                        //    Debugger.Break();
                        //}
                        //if (currentRead.ToString() == "ACTGGGCGGTGAAGCCGAAAAACTGCTCTTCCGCTTCCGCGACAACGGCGGGC")
                        //    Debugger.Break();

                        CountMatchesForRead(currentRead, incFilters, excFilters, merSize, ref merSet, ref merValid, incMatchesForRead, excMatchesForRead, matchedAcceptedMerLocs, matchedRejectedMerLocs, lowComplexityFilter, LCDistinct);

                        for (int f = 0; f < incFilters.Count; f++)
                        {
                            bool passedThisFilter = incMatchesForRead[f] >= incFilterMinsRead[f];
                            if (passedThisFilter && fullLength)
                                passedThisFilter = FullLengthMatches(currentReadLength, merSize, matchedAcceptedMerLocs[f], incMatchesForRead[f], minInHalf);
                            acceptedRead[p][r] = acceptedRead[p][r] | passedThisFilter;
                        }

                        for (int f = 0; f < excFilters.Count; f++)
                        {
                            bool failedThisFilter = excMatchesForRead[f] >= excFilterMinsRead[f];
                            if (failedThisFilter && fullLength)
                                failedThisFilter = FullLengthMatches(currentReadLength, merSize, matchedRejectedMerLocs[f], excMatchesForRead[f], minInHalf);
                            rejectedRead[p][r] = rejectedRead[p][r] | failedThisFilter;

                            //if (failedThisFilter && lowComplexityFilter && f == excFilters.Count-1)
                            //    lock (rejects)
                            //    {
                            //        rejects.WriteLine(headerSet[r][b].ToString() + " LCF: " + excMatchesForRead[f]);
                            //        rejects.WriteLine(readSet[r][b].ToString());
                            //    }
                        }

                        if (rejectedRead[p][r])
                        {
                            acceptedRead[p][r] = false;        // rejected trumps accepted
                            progressReadsRejected++;
                        }

                        if (saveMatches)
                        {
                            savedMatchedAcceptLocs[p][r].Clear();
                            savedMatchedRejectLocs[p][r].Clear();
                            for (int f = 0; f < incFilters.Count; f++)
                                foreach (int loc in matchedAcceptedMerLocs[f])
                                    savedMatchedAcceptLocs[p][r].Add(loc);
                            int lcfIdx = lowComplexityFilter ? excFilters.Count - 1 : -1;
                            for (int f = 0; f < excFilters.Count; f++)
                                foreach (int loc in matchedRejectedMerLocs[f])
                                {
                                    savedMatchedRejectLocs[p][r].Add(loc);
                                    int kMerSize = f == lcfIdx? lcSize : merSize;
                                    savedMatchedRejectSizes[p][r].Add(kMerSize);
                                }
                        }

                        //if (saveMatches)
                        //{
                        //    matches.WriteLine(headerSet[r][b].ToString() + " A=" + acceptedRead[p][r] + " R=" + rejectedRead[p][r]);
                        //    WriteMatchDetails(matches, "inc", incFilterMinsRead, incMatchesForRead, matchedAcceptedMerLocs);
                        //    WriteMatchDetails(matches, "exc", excFilterMinsRead, excMatchesForRead, matchedRejectedMerLocs);
                        //}

                    } // for each read in the file set
                } // for each read in the set

                // if reading fastq but writing fasta, change the header character before writing the filtered read
                for (int p = 0; p < noOfReadsFiles; p++)
                    for (int r = 0; r < readsRead; r++)
                        if (outputFormat == SeqFiles.formatFNA && headerSet[p][r].Bases[0] == '@')
                            headerSet[p][r].Bases[0] = '>';

                // and now write the filtered read
                lock (writingLock)
                {
                    for (int r = 0; r < readsRead; r++)
                    {
                        if (pairedReads)
                        {
                            if (acceptedRead[0][r] && acceptedRead[1][r])
                            {
                                pairedAcceptedReads++;
                                progressReadsAccepted += 2;
                                matchingReads += 2;

                                SeqFiles.WriteRead(filteredReads[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                                SeqFiles.WriteRead(filteredReads[1], headerSet[1][r], readSet[1][r], qualHeaderSet[1][r], qualsSet[1][r], outputFormat);

                                if (saveMatches)
                                {
                                    WriteMatchingSeq(merSize, savedMatchedAcceptLocs[0][r], savedMatchedRejectSizes[0][r], savedMatchedRejectLocs[0][r], readsDisplayFNs[0], headerSet[0][r], readSet[0][r]);
                                    WriteMatchingSeq(merSize, savedMatchedAcceptLocs[1][r], savedMatchedRejectSizes[0][r], savedMatchedRejectLocs[1][r], readsDisplayFNs[1], headerSet[1][r], readSet[1][r]);
                                }
                            }
                            else
                            {
                                rejectedReads += 2;

                                if (discardedReads != null)
                                {
                                    SeqFiles.WriteRead(discardedReads[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                                    SeqFiles.WriteRead(discardedReads[1], headerSet[1][r], readSet[1][r], qualHeaderSet[1][r], qualsSet[1][r], outputFormat);
                                }
                            }
                        }
                        else
                        {
                            if (acceptedRead[0][r])
                            {
                                progressReadsAccepted++;
                                matchingReads++;

                                SeqFiles.WriteRead(filteredReads[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                                if (saveMatches)
                                    WriteMatchingSeq(merSize, savedMatchedAcceptLocs[0][r], savedMatchedRejectSizes[0][r], savedMatchedRejectLocs[0][r], readsDisplayFNs[0], headerSet[0][r], readSet[0][r]);
                                //Console.WriteLine(headerSet[r][b].ToString() + " inc=" + totalAccepted + " exc=" + totalRejected);
                            }
                            else
                            {
                                rejectedReads++;
                                
                                if (discardedReads != null)
                                    SeqFiles.WriteRead(discardedReads[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                            }
                        }

                    } // writing a batch of reads
                } // writing lock
            } // until all files are at EOF

            theseParams.acceptedReads = matchingReads;
            theseParams.rejectedReads = rejectedReads;
            theseParams.skippedReadsShort = skippedReadsShort;
            theseParams.pairedAcceptedReads = pairedAcceptedReads;
            theseParams.basesQualTrimmed = basesQualTrimmed;
            theseParams.noOfReads = noOfReads;
        }

        private static void WriteMatchDetails(StreamWriter matches, string type, int[] filterMins, int[] matchesForRead, List<int>[] matchedMerLocs)
        {
            for (int f = 0; f < matchesForRead.Length; f++)
            {
                matches.Write(type + " [" + f + "]: ");

                List<int> ml = matchedMerLocs[f];
                matches.Write("(" + matchesForRead[f] + "/" + filterMins[f] + ") ");
                foreach (int m in ml)
                    matches.Write(m + " ");

                matches.WriteLine();
            }
        }

        private static bool FullLengthMatches(int readLength, int merSize, List<int> matchedMerLocs, int basesMatched, int minInHalf)
        {
            int matchesInFirstHalf = ConvertMatchesToCoveredBases(matchedMerLocs, merSize, readLength/2);
            int matchesInSecondHalf = basesMatched - matchesInFirstHalf;

            return (matchesInFirstHalf >= minInHalf && matchesInSecondHalf >= minInHalf);
        }

        private static void CheckForLowComplexity(Sequence read, ref ulong[] merSet, ref bool[] merValid, List<int> LCLocs, Dictionary<ulong, int> distinctSet)
        {
            distinctSet.Clear();

            int tripletsCount = Sequence.GenerateMersFromRead(read, lcSize, ref merSet, ref merValid);

            for (int i = 0; i < tripletsCount; i++)
            {
                if (merValid[i])
                {
                    ulong triplet = merSet[i];
                    if (distinctSet.ContainsKey(triplet))
                        distinctSet[triplet]++;
                    else
                        distinctSet.Add(triplet, 1);
                }
            }

            int maxCount = 0;
            int secondCount = 0;
            ulong maxKey = 0;
            ulong secondKey = 0;

            foreach (KeyValuePair<ulong, int> kvp in distinctSet)
            {
                int count = kvp.Value;
                if (count >= maxCount)
                {
                    secondCount = maxCount;
                    secondKey = maxKey;
                    maxCount = count;
                    maxKey = kvp.Key;
                }
            }

            int topTwoCount = maxCount + secondCount;
            int cutOff = tripletsCount / 5;

            if (topTwoCount > cutOff)
            {
                LCLocs.Clear();
                for (int i = 0; i < tripletsCount; i++)
                    if (merValid[i])
                    {
                        ulong triplet = merSet[i];
                        if (triplet == maxKey || triplet == secondKey)
                            LCLocs.Add(i);
                    }
            }
        }

        private static void WriteMatchingSeq(int acceptMerSize, List<int> matchedAcceptedMerLocs, List<int> matchedRejectedMerSizes, List<int> matchedRejectedMerLocs, string FN, Sequence header, Sequence read)
        {
            string blanks = new string(' ', read.Length);
            StringBuilder markersSB = new StringBuilder(blanks);
            int acceptedMatches = 0;
            int rejectedMatches = 0;

            foreach (int loc in matchedAcceptedMerLocs)
            {
                for (int b = 0; b < acceptMerSize; b++)
                    markersSB[loc + b] = '^';
                acceptedMatches++;
            }

            for (int i = 0; i < matchedRejectedMerLocs.Count; i++)
            {
                int loc = matchedRejectedMerLocs[i];
                int rejectedMerSize = matchedRejectedMerSizes[i];
                for (int b = 0; b < rejectedMerSize; b++)
                    markersSB[loc + b] = 'X';
                rejectedMatches++;
            }
            string markers = markersSB.ToString();

            int readLength = read.Length;
            int lengthWritten = 0;
            lock (matches)
            {
                matches.WriteLine(FN + ":");
                matches.WriteLine(header.ToString() + " +" + acceptedMatches + "/-" + rejectedMatches);

                for (int i = 0; i < readLength; i += 60)
                {
                    string readFragment = read.ToString(i, Math.Min(60, readLength - lengthWritten));
                    string markersFragment = markers.Substring(i, Math.Min(60, readLength - lengthWritten));
                    if (markersFragment.Contains('^') || markersFragment.Contains('X'))
                    {
                        matches.WriteLine(i.ToString("D6") + " " + readFragment);
                        matches.WriteLine("       " + markersFragment.TrimEnd());
                    }
                    lengthWritten += 60;
                }
            }
        }

        private static void CountMatchesForRead(Sequence read, List<MerHashSet> incFilters, List<MerHashSet> excFilters, 
                                               int merSize, ref ulong[] merSet, ref bool[] merValid,
                                               int[] incMatchesForRead, int[] excMatchesForRead, List<int>[] matchedAcceptedMersLocs, List<int>[] matchedRejectedMersLocs,
                                               bool lowComplexityFilter, Dictionary<ulong, int> LCDistinct)
        {
            int NsInReads = 0;
            int lcfIdx = lowComplexityFilter ? excFilters.Count - 1 : -1;

            Array.Clear(incMatchesForRead, 0, incMatchesForRead.Length);
            Array.Clear(excMatchesForRead, 0, excMatchesForRead.Length);

            if (lowComplexityFilter)
                CheckForLowComplexity(read, ref merSet, ref merValid, matchedRejectedMersLocs[lcfIdx], LCDistinct);

            int mersInRead = Sequence.GenerateMersFromRead(read, merSize, ref merSet, ref merValid);

            // match kMers against all the filters and remember where they matched
            for (int m = 0; m < mersInRead; m++)
            {
                if (merValid[m])
                {
                    MatchMer(merSet[m], merSize, incFilters, excFilters, m, matchedAcceptedMersLocs, matchedRejectedMersLocs);
                }
                else
                {
                    NsInReads++;
                }
            } // all mers in read

            // convert matching locations to counts of covered bases
            for (int f = 0; f < incFilters.Count; f++)
            {
                if (matchedAcceptedMersLocs[f].Count > 0)
                    incMatchesForRead[f] = ConvertMatchesToCoveredBases(matchedAcceptedMersLocs[f], merSize, read.Length);
                else
                    incMatchesForRead[f] = 0;
            }
            for (int f = 0; f < excFilters.Count; f++)
            {
                if (matchedRejectedMersLocs[f].Count > 0)
                    excMatchesForRead[f] = ConvertMatchesToCoveredBases(matchedRejectedMersLocs[f], f == lcfIdx ? lcSize : merSize, read.Length);
                else
                    excMatchesForRead[f] = 0;
            }
        }

        private static int ConvertMatchesToCoveredBases(List<int> matchLocs, int merSize, int readLength)
        {
            int basesCovered = 0;
            int lastMerNo = readLength - merSize;
            for (int m = 0; m < matchLocs.Count - 1; m++)
            {
                // can only happen if we're looking at half the read
                if (matchLocs[m] > lastMerNo)
                    break;

                int basesCoveredByMatch = matchLocs[m + 1] - matchLocs[m];
                if (basesCoveredByMatch > merSize)
                    basesCoveredByMatch = merSize;
                basesCovered += basesCoveredByMatch;
            }
            if (matchLocs.Count > 0 && matchLocs[matchLocs.Count-1] < lastMerNo)
                basesCovered += merSize;

            return basesCovered;
        }

        private static void MatchMer(ulong mer, int merSize, List<MerHashSet> incFilters, List<MerHashSet> excFilters, int m, List<int>[] matchedAcceptedMersLocs, List<int>[] matchedRejectedMersLocs)
        {
            // get the canonical form of the current mer
            ulong rcMer = kMers.ReverseComplement(mer, merSize);
            if (rcMer < mer)
                mer = rcMer;

            for (int f = 0; f < incFilters.Count; f++)
            {
                if (incFilters[f].Contains(mer))
                    matchedAcceptedMersLocs[f].Add(m);
            }
            for (int f = 0; f < excFilters.Count; f++)
            {
                if (excFilters[f] != null && excFilters[f].Contains(mer))
                    matchedRejectedMersLocs[f].Add(m);
            }
        }

        private static int GenerateMerSubVariants(ulong mer, List<ulong> merVariants, int merSize)
        {
            int start = 0;
            //merVariants.Clear();
            int variantsAdded = 0;

            ulong baseMask = 0xc000000000000000;

            for (int m = start; m < merSize; m++)
            {
                ulong merWithHole = mer & ~(baseMask >> (m * 2));
                for (ulong b = 0; b <= 3; b++)
                {
                    ulong newBase = b << (64 - (m + 1) * 2);
                    ulong merVariant = merWithHole | newBase;
                    if (merVariant == mer)
                        continue;
                    merVariants.Add(merVariant);
                    variantsAdded++;
                }
            }
            return variantsAdded;
        }

        static void RateReporter()
        {
            DateTime lastTimeAwake = DateTime.Now;
            long lastReadsCount = 0;

            while (!stopReporter)
            {
                Thread.Sleep(reportInterval);

                DateTime timeNow = DateTime.Now;
                double timeTaken = (timeNow - lastTimeAwake).TotalSeconds;
                lastTimeAwake = timeNow;
                long currentReadsCount = progressReadsRead;
                long readsInTime = currentReadsCount - lastReadsCount;
                lastReadsCount = currentReadsCount;
                int readsRate = (int)((double)readsInTime / timeTaken);

                Console.WriteLine("filtered +" + progressReadsAccepted + ",-" + progressReadsRejected + " from " + currentReadsCount + " sequences at " + readsRate + " rps");
            }
        }
    }

    public class readerThreadParams
    {
        public List<MerHashSet> incFilters;
        public List<int> incFilterMins;
        public List<bool> incFilterPct;
        public List<MerHashSet> excFilters;
        public List<int> excFilterMins;
        public List<bool> excFilterPct;
        public int merSize;
        public int minLen;
        public BufferedReader[] bufferedReads;
        public int fileFormat;
        public int outputFormat;
        public int minQual;
        public int qualOffset;
        public string[] readsDisplayFNs;
        public StreamWriter[] filteredReads;
        public StreamWriter[] discardedReads;
        public long acceptedReads;
        public long rejectedReads;
        public long pairedAcceptedReads;
        public long skippedReadsShort;
        public long basesQualTrimmed; 
        public long noOfReads;
    }

}

